#!/usr/bin/env python3

import xml.etree.ElementTree as ET
import sys
from colorama import Fore
import zipfile
from rich.progress import track
import os
import re
import subprocess
import uuid
from io import BytesIO
import tempfile
import csv
from xml.dom import minidom
import concurrent.futures
from rich.progress import Progress, TimeElapsedColumn, BarColumn, SpinnerColumn, TimeRemainingColumn, TransferSpeedColumn
from xml_utils import *
import time
import re
import cProfile
import pstats

FOXML_NAMESPACES = {
    'dc': 'http://purl.org/dc/elements/1.1/',
    'foxml': 'info:fedora/fedora-system:def/foxml#',
    'ns2': 'info:fedora/fedora-system:def/audit#',
    'ns3': "http://www.loc.gov/mods/v3",
    'ns4': 'info:fedora/fedora-system:def/relations-external#',
    'ns5': 'info:fedora/fedora-system:def/model#',
    'ns6': 'http://islandora.ca/ontology/relsext#',
    'ns7': 'http://www.openarchives.org/OAI/2.0/oai_dc/',
    'ns8': 'http://islandora.ca/ontology/relsext#',
    'ns9': 'urn:oasis:names:tc:xacml:1.0:policy',
    'rdf': 'http://www.w3.org/1999/02/22-rdf-syntax-ns#',
    'xsi': 'http://www.w3.org/2001/XMLSchema-instance',
    'mods': "http://www.loc.gov/mods/v3" 
}


def setup_namespaces():
    """ Sets up the namespaces for the XML tree. """
    ET.register_namespace("dc", 'http://purl.org/dc/elements/1.1/')
    ET.register_namespace("foxml", 'info:fedora/fedora-system:def/foxml#')
    ET.register_namespace('audit', 'info:fedora/fedora-system:def/audit#')
    ET.register_namespace('fedora', 'info:fedora/fedora-system:def/relations-external#')
    ET.register_namespace('fedora-model', 'info:fedora/fedora-system:def/model#')
    ET.register_namespace('islandora', 'http://islandora.ca/ontology/relsext#')
    ET.register_namespace('oai_dc', 'http://www.openarchives.org/OAI/2.0/oai_dc/')
    ET.register_namespace('Policy', 'urn:oasis:names:tc:xacml:1.0:policy')
    ET.register_namespace('rdf', 'http://www.w3.org/1999/02/22-rdf-syntax-ns#')
    ET.register_namespace('xsi', 'http://www.w3.org/2001/XMLSchema-instance')
    ET.register_namespace('', 'http://www.loc.gov/mods/v3')

def print_help() -> None:
    # Open help.txt and print its contents
    with open('help.txt', 'r') as help_file:
        print(help_file.read())

def display_logo() -> None:
    # Open logo.txt and print its contents
    with open('logo.txt', 'r') as logo_file:
        print(Fore.YELLOW, logo_file.read(), Fore.RESET)

def print_usage() -> None:
    print(Fore.RED, "Usage: ./foxtrot [OPTION] <INPUT_DIRECTORY> [OUTPUT_DIRECTORY]", Fore.RESET)
    print(Fore.RED, "Try './foxtrot --help' for more information.", Fore.RESET)
    exit(127)

def parse_arguments(arguments: list[str]) -> dict:
    """
    Parse the <arguments> passed to this script via the command line and return the path of the input directory.

    Args:
        arguments (list[str]): The list of arguments passed to the script.

    Returns:
        dict: A dictionary containing parsed options and paths. The dictionary may contain the following keys:
            - 'options': A set of parsed options provided as command-line flags.
            - 'input': The path of the input directory (required).
            - 'output': The path of the output directory (optional).
    """

    # Initialize the dictionary to store parsed options and paths
    ret = {'options': set()}

    # Loop through the arguments
    for argument in arguments[1:]:
        if argument.startswith('--'):  # Check for long options like "--no_multithreading"
            if argument == '--help':
                print_help()  # If the argument is "--help", print help
            ret['options'].add(argument[2:])
        elif argument.startswith('-'):  # Check for short options like "-h"
            for option in argument[1:]:
                if option == 'h':
                    print_help() # If the argument is "-h", print help
                ret['options'].add(option)
        elif os.path.isdir(argument):  # Check if the argument is a directory
            if 'input' not in ret:
                ret['input'] = argument  # Store the argument as the input directory
            elif 'output' not in ret:
                ret['output'] = argument  # Store the argument as the output directory
            else:
                print_usage()  # If both input and output directories are already set, print usage
        elif 'input' not in ret or 'output' not in ret:
            print(Fore.RED, f"foxtrot: {argument}: No such directory", Fore.RESET)
            exit(127)
        else:
            print_usage()  # If argument is not recognized as an option or a directory, print usage

    if 'input' not in ret:
        print_usage()  # If no input directory is provided, print usage

    return ret
    
def create_uniquely_named_directory() -> str:
    """ Creates a uniquely-named directory in the system's temp directory and returns its path. 
    The directory name is generated using UUID, and will have the form 'dir_<UUID>'. """

    # Get the system's temporary directory location
    temp_dir = tempfile.gettempdir()

    # Generate a unique directory name using UUID
    unique_name = "dir_" + str(uuid.uuid4())

    # Combine the temp_dir and unique_name to get the full path of the new directory
    new_directory_path = os.path.join(temp_dir, unique_name)

    # Create the directory if it doesn't exist
    os.makedirs(new_directory_path, exist_ok=False)

    return new_directory_path
    
def format_drush_command_from_atomzip(zip_path: str) -> str:
    """Return 'drush @dsu --user=1 create-islandora-bag object COLLECTION:PID', where <zip_path> is of the form .../COLLECTION_PID_foxml_atomzip.zip"""

    # Extract the COLLECTIONNAME:PID from the zip_path
    zip_filename = os.path.basename(zip_path).replace('_foxml_atomzip.zip', '')
    
    # Find the last index of '_' in the filename
    last_underscore_index = zip_filename.rfind('_')
    
    # Split the filename into COLLECTION and PID parts using the last underscore index
    collection_name = zip_filename[:last_underscore_index]
    pid = zip_filename[last_underscore_index + 1:]

    # Combine COLLECTION and PID with ':' and return the formatted drush command
    return f"drush @dsu --user=1 create-islandora-bag object {collection_name}:{pid}"


def extract_bag_path_from_drush_command_stdout(stdout_bytes: bytes) -> str:
    """Given <stdout_bytes> from the 'drush @dsu --user=1 create-islandora-bag object COLLECTION:PID' command, return the path of the newly created ZIP file."""
    # Decode the stdout bytes to a string
    stdout = stdout_bytes.decode('utf-8')
    
    # Define a regular expression pattern to match the bag path up to ".zip"
    pattern = r"Bag created and saved at ([^\n]+?\.zip)"
    
    # Use re.findall() to find all occurrences of the pattern in the stdout
    matches = re.findall(pattern, stdout)
    
    if matches:
        # Extract the path from the first matched group (up to ".zip")
        bag_path = matches[0]
        return bag_path.strip()  # Remove any leading/trailing whitespace from the path
    else:
        return None  # Return None if no path is found in the stdout
    


def get_bag_name_from_atomzip(atomzip_path: str) -> str:
    """ Given an <atomzip_path>, return the name of the bag contained in the atomzip name. """
    return os.path.basename(atomzip_path).replace('_foxml_atomzip.zip', '')



def process_container_zip(outer_directory: str, target_zip_name: str, return_directory: str, bag_name_and_new_foxml: list[str, str]) -> None:
    try:
        # Generate the name of and create the directory which the FOXML files for this container will be written to
        # The directory name is the same as the container zip file name, but without the .zip extension
        output_directory = f'{return_directory}/{os.path.basename(target_zip_name).replace(".zip", "")}'
        os.makedirs(output_directory)

        # This flag represents whether we found the first atomzip file in the container. 
        # The reasoning is that the atomzip whose name matches that of the container owns the one and only FOXML in the container.
        # All the other atomzip files need to have their FOXMLs generated for them.
        found_first_atomzip = False
        with zipfile.ZipFile(f'{outer_directory}/{target_zip_name}', 'r') as input_zip_archive:
            # Loop over all file/directory names in the zip file without unzipping it
            for name in input_zip_archive.namelist():
                start_time = time.time()
                # Check if the file matches the desired pattern (inside data directory and ends with _foxml_atomzip.zip)
                if 'data/' in name and name.endswith('_foxml_atomzip.zip'):
                    # Get the name of the bag from the atomzip file name
                    bag_name = get_bag_name_from_atomzip(name)

                    # Do not run Drush command for the atomzip whose name matches the container's, as the foxml file is already in the given ZIP
                    # Keeping track of found_first_atomzip short-circits the condition and prevents repeated string comparisons
                    if not found_first_atomzip and bag_name in target_zip_name:
                        found_first_atomzip = True
                        # Generate the root directly from the FOXML in the ZIP
                        foxml_tree = get_xml_tree_from_zip('foxml.xml', input_zip_archive)
                    else:
                        # Execute the Drush command to create a FOXML file from this ZIP file
                        result = subprocess.run(format_drush_command_from_atomzip(name), shell=True, stdout=subprocess.PIPE, stderr=subprocess.DEVNULL)
                        # Extract the path of the newly created ZIP file (by the Drush command), which will contain the FOXML file in it
                        drush_generated_path = extract_bag_path_from_drush_command_stdout(result.stdout)
                        if not drush_generated_path:
                            print(Fore.RED, f"Drush command failed for {name}. Skipping this bag.", Fore.RESET)
                            continue
                        # Find the FOXML in the Drush-generated ZIP, and get the root from there
                        with zipfile.ZipFile(drush_generated_path, 'r') as drush_zip_archive:
                            foxml_tree = get_xml_tree_from_zip('foxml.xml', drush_zip_archive)

                    # We now convert managed FOXML to inline, and leave already inline FOXML as is
                    with zipfile.ZipFile(BytesIO(input_zip_archive.read(name)), 'r') as atomzip_archive:
                        process_foxml_tree(foxml_tree, atomzip_archive)
                    
                    xml_string = ET.tostring(foxml_tree.getroot(), encoding='utf8', method='xml').decode()


                    # Here we use xmllint to beautify the XML
                    # Prepare the xmllint command and arguments
                    command = ["xmllint", "--format", "-"]
                    try:
                        process = subprocess.Popen(command, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
                        stdout, _ = process.communicate(input=xml_string, timeout=10)

                        # Check for any errors
                        if process.returncode == 0:
                            xml_string = stdout

                    except Exception as e:
                        print(Fore.RED, f'Unable to beautify FOXML for {bag_name}:', str(e))

                    # Create the directory where the new FOXML for this bag will be saved
                    foxml_save_directory = os.path.join(output_directory, bag_name)
                    os.makedirs(foxml_save_directory)
                    converted_foxml_path = f'{foxml_save_directory}/foxml.xml'

                    # Write the formatted XML string to the file
                    with open(converted_foxml_path, 'w') as converted_foxml_file:
                        converted_foxml_file.write(xml_string)
                    
                    # Document the mapping of the bag name to the converted FOXML path
                    bag_name_and_new_foxml.append([bag_name, converted_foxml_path])
                    print(Fore.GREEN, f'Converted FOXML for {bag_name} and saved to {converted_foxml_path} in {time.time() - start_time} seconds', Fore.RESET)
    except Exception as e:
        print(Fore.RED, f'Failed to process {target_zip_name}:', str(e), Fore.RESET)
        return



def run(input_dir: str, zip_files: list[str], return_directory: str, bag_name_and_new_foxml: list[str, str]) -> None:
    progress = Progress(
        "[progress.description]{task.description}",
        SpinnerColumn(),
        TimeElapsedColumn(),
        "[progress.percentage]{task.percentage:>3.0f}%",
        BarColumn(),
        "[progress.completed]{task.completed}/{task.total}"
    )

    with progress:
        task = progress.add_task("[cyan]Processing", total=len(zip_files))

        with concurrent.futures.ThreadPoolExecutor(max_workers=os.cpu_count()) as executor:
            futures = [executor.submit(process_container_zip, input_dir, zip, return_directory, bag_name_and_new_foxml) for zip in zip_files]

            for _ in concurrent.futures.as_completed(futures):
                progress.advance(task)

def multithreaded(return_directory: str, input_dir: str, bag_name_and_new_foxml: list[str, str]):
    # Get the names of all zip files in the input directory
    zip_files = [zip_file for zip_file in os.listdir(input_dir) if zip_file.endswith('.zip')]

    run(input_dir, zip_files, return_directory, bag_name_and_new_foxml)

    # Write the mapping of bag names to converted FOXML paths to a CSV file
    with open(f'{return_directory}/map.csv', 'w', newline='') as map:
        writer = csv.writer(map)
        # Write the column names to the CSV file
        writer.writerow(['bag_name','converted_foxml_path'])
        # Write the accumulated data to the CSV file in bulk
        writer.writerows(bag_name_and_new_foxml)

def singlethreaded(return_directory: str, input_dir: str, bag_name_and_new_foxml: list[str, str]) -> None:
    for zip_file in track(os.listdir(input_dir), description='Processing...'):
        if zip_file.endswith('.zip'):
            process_container_zip(input_dir, zip_file, return_directory, bag_name_and_new_foxml)

    # Write the mapping of bag names to converted FOXML paths to a CSV file
    with open(f'{return_directory}/map.csv', 'w', newline='') as map:
        writer = csv.writer(map)
        # Write the column names to the CSV file
        writer.writerow(['bag_name','converted_foxml_path'])
        # Write the accumulated data to the CSV file in bulk
        writer.writerows(bag_name_and_new_foxml)



# Parse command line arguments
arguments = parse_arguments(sys.argv)

display_logo()

setup_namespaces()

# Create the directory which will store the FOXML files
if 'output' in arguments:
    if not os.path.exists(arguments['output']):
        os.makedirs(arguments['output'])
    return_directory = arguments['output']
else:
    return_directory = create_uniquely_named_directory()

print(Fore.YELLOW, f"Conversion has started. The output directory is {return_directory}")
print(Fore.YELLOW, f'Please refer to {return_directory}/map.csv for a mapping of bags to their converted FOXML files.', Fore.RESET)


# This list will contain as its first element the name of a bag and as its second element the path to the converted FOXML file
bag_name_and_new_foxml = []
if os.cpu_count() > 1 and 'no_multithreading' not in arguments['options']:
    multithreaded(return_directory, arguments['input'], bag_name_and_new_foxml)
else:
    singlethreaded(return_directory, arguments['input'], bag_name_and_new_foxml)



            


